5

S->a|bA|B|ccD|Pc
A->abB|epsilon|P
P->ppP | A
B->aA
C->ddC
D->ddd
E->eE | F
F->fF | G
G->gG


从 S 开始 DFS, 考虑 S 右边的所有项中的大写字母, 比如 ccD 只考虑 D
    - DFS 右边这些大写字母, 去掉所有DFS完这些大写字母都不可达的大写字符集 E F G
    - 只需要判断是大写字符是否可达, 某个大写字符不可达, 就要删除所有含有这个大写字符的产生式
    - 枚举每个产生式然后判断是否在其他产生式右边出现过思路是错的, E F G 这三项就可以证明

考虑图中有环的特殊情况, 上述样例中 A P 的关系:

- 假设先搜索到 A, 然后标记 A 为搜索过,然后 A 出发搜索邻接点 P, 标记 P 为搜索过, 从 P 出发遇到 A 发现已经搜过就不再搜 A, 然后考虑 P->ppP 这个递归式，
这个式子是不可达的，要特殊判断递归式的格式，包括左递归和右递归。搜索完 P 的所有项了递归返回结果是 P 为不可达状态。如果不标记A是否搜过，再去搜 A 就会陷入死循环。

- 直接将 A 代入 P 产生式得到 P->ppP|abB|epsilon|P, 那么此时P->epsilon 是可达的, 但是如何处理 P-> P, 以及如何用代码实现“代入” ?

到底 A 和 P 的推导关系该如何处理得到正确结果, 同时保证 DFS 不会无限递归陷入死循环 ?

